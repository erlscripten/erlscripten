-module(erlscripten).
-author("gorbak25").

-export([parse_transform/2]).

version() -> "v0.0.1".

parse_transform(Forms, Options) ->
    code:ensure_loaded(erlscripten_logger),
    application:ensure_started(erlscripten),
    Attributes = [X || X <- lists:map(fun filter_module_attributes/1, Forms), is_tuple(X)],
    FileName = proplists:get_value(file, Attributes),
    try
        ModuleName = proplists:get_value(module, Attributes),
        erlscripten_logger:info("Transpiling ~s", [ModuleName]),
        case proplists:get_value(erlscripten_output, Attributes) of
            undefined ->
                erlscripten_logger:die(FileName, "Please add -erlscripten_output(DIRECTORY). To indicate where the autogenerated spago project will be placed\n");
            Dir ->
                [BasePath|_] = string:split(proplists:get_value(outdir, Options), "_build"),
                OutDir = filename:join(BasePath, Dir),
                generate_template(OutDir),
                SrcDir = filename:join(OutDir, "src"),
                %% Ok now let's do some preliminary work before starting the conversion
                %% Gather record types
                Records = maps:from_list(proplists:get_all_values(record, Attributes)),
                %% Create the Purescript module
                PursModuleFile = filename:join(SrcDir, erlang_module_to_purs_file(ModuleName)),
                file:delete(PursModuleFile),
                {ok, Handle} = file:open(PursModuleFile, [write]),
                write_line(Handle, 0, "module ~s where", [erlang_module_to_purs_module(ModuleName)]),
                write_line(Handle, 0, "{-", []),
                write_lines(Handle, 1, [
                    {"This file has been autogenerated", []},
                    {"DO NOT EDIT - Your changes WILL be overwritten", []},
                    {"Use this code at your own risk - the author is just a mischievous raccoon", []},
                    {"Erlscripten ~s", [version()]}
                ]),
                write_line(Handle, 0, "-}", []),
                write_line(Handle, 0, "", []),
                %% Ok It's time for some canonical imports which will be used a lot :)
                write_lines(Handle, 0, [
                    {"import Prelude", []},
                    {"import Erlang.Type (ErlangTerm(..))", []},
                    {"import Effect (Effect)", []},
                    %%{"import Effect.Unsafe (unsafePerformEffect)", []},
                    {"", []}
                ]),
                %% Now it's time to determine what modules to import
                %% First filter out functions to transpile
                FunctionForms = [X || X <- lists:map(fun filter_function_forms/1, Forms), is_tuple(X)],
                FunctionNames = sets:from_list([Name || {Name, _} <- FunctionForms]),
                %% Now walk the entire AST and search for calls/remote_calls
                Calls = lists:usort([X || X <- lists:flatten([import_resolver_fun_clauses(X, FunctionNames) || {_, X} <- FunctionForms]), X /= undefined]),
                erlscripten_logger:debug("Module calls: ~p", [Calls]),
                Imports = lists:usort([M || {M, _} <- Calls]),
                [write_line(Handle, 0, "import ~s as ~s", [erlang_module_to_purs_module(Import), erlang_module_to_qualified_import(Import)]) || Import <- Imports],
                write_line(Handle, 0, "", []),
                %% Now do the dirty work - transpile every function OwO
                [transpile_function(Function, Records, FunctionNames, Handle) || Function <- FunctionForms]
        end,
        Forms
    catch Error:Reason:StackTrace ->
        erlscripten_logger:die(FileName,
            io_lib:format("Error: ~s\nReason: ~p\nStacktrace: ~p\n", [atom_to_list(Error), Reason, StackTrace])
        )
    end.

filter_module_attributes({attribute, _, file, {Filename, _}}) -> {file, Filename};
filter_module_attributes({attribute, _, module, Module}) when is_atom(Module) -> {module, atom_to_list(Module)};
filter_module_attributes({attribute, _, export, Exports}) -> {export, Exports};
filter_module_attributes({attribute, _, record, {RecordName, RecordFields}}) -> {record, {RecordName, lists:map(fun record_fields/1, RecordFields)}};
filter_module_attributes({attribute, _, erlscripten_output, Directory}) when is_atom(Directory) -> {erlscripten_output, atom_to_list(Directory)};
filter_module_attributes({attribute, _, erlscripten_output, Directory}) when is_binary(Directory) -> {erlscripten_output, binary_to_list(Directory)};
filter_module_attributes({attribute, _, erlscripten_output, Directory}) when is_list(Directory) -> {erlscripten_output, Directory};
filter_module_attributes(_) -> undefined.

record_fields({record_field, _, {atom, N, FieldName}}) -> {FieldName, {atom, N, undefined}};
record_fields({record_field, _, {atom, _, FieldName}, Default}) -> {FieldName, Default};
record_fields({typed_record_field, RecordField, _}) -> record_fields(RecordField).

generate_template(DestDir) ->
    SupportDir = filename:join(code:priv_dir(erlscripten), "support"),
    copy_recursive(SupportDir, DestDir).

copy_recursive(Source, Dest) ->
    case filelib:is_dir(Source) of
        true ->
            case filelib:is_dir(Dest) of
                false ->
                    file:make_dir(Dest);
                true ->
                    ok
            end,
            {ok, Names} = file:list_dir(Source),
            [copy_recursive(filename:join(Source, Name), filename:join(Dest, Name)) || Name <- Names];
        false ->
            file:copy(Source, Dest)
    end.

erlang_module_to_purs_module(Name) when is_atom(Name) ->
    erlang_module_to_purs_module(atom_to_list(Name));
erlang_module_to_purs_module(Name) ->
    string:join(lists:map(fun string:titlecase/1, string:split(Name, "_", all)), ".").

erlang_module_to_qualified_import(Name) when is_atom(Name) ->
    erlang_module_to_qualified_import(atom_to_list(Name));
erlang_module_to_qualified_import(Name) ->
    string:join(lists:map(fun string:titlecase/1, string:split(Name, "_", all)), "").

erlang_module_to_purs_file(Name) when is_atom(Name) ->
    erlang_module_to_purs_file(atom_to_list(Name));
erlang_module_to_purs_file(Name) ->
    string:join(lists:map(fun string:titlecase/1, string:split(Name, "_", all)), "") ++ ".purs".

write_lines(Handle, IdentLevel, Lines) ->
    [write_line(Handle, IdentLevel, Format, Args) || {Format, Args} <- Lines].
write_line(Handle, IdentLevel, Format, Args) ->
    file:write(Handle, string:copies("    ", IdentLevel) ++ io_lib:format(Format, Args) ++ "\n").

filter_function_forms({function, _, FunName, Arity, Clauses}) ->
    {{atom_to_list(FunName), Arity}, Clauses};
filter_function_forms(_) ->
    undefined.

import_resolver_fun_clauses(Clauses, FNames) ->
    [import_resolver_fun_clause(X, FNames) || X <- Clauses].
import_resolver_fun_clause({clause, _, _Args, Guards, Body}, FNames) ->
    [ [import_resolver_fun_oplist(Guard, FNames) || Guard <- Guards]
    , [import_resolver_fun_oplist(Body, FNames)]].

import_resolver_fun_oplist(Ops, FNames) ->
    [import_resolver_fun_op(Op, FNames) || Op <- Ops].

import_resolver_fun_op({atom, _, _}, _) -> undefined;
import_resolver_fun_op({integer, _, _}, _) -> undefined;
import_resolver_fun_op({string, _, _}, _) -> undefined;
import_resolver_fun_op({var, _, _}, _) -> undefined;
import_resolver_fun_op({nil, _}, _) -> undefined;
import_resolver_fun_op({bin, _, BinElements}, FNames) ->
    import_resolver_fun_oplist([Op || {bin_element, _, Op, _, _} <- BinElements], FNames);
import_resolver_fun_op({tuple, _, Ops}, FNames) ->
    import_resolver_fun_oplist(Ops, FNames);
import_resolver_fun_op({op, _, _, Arg1, Arg2}, FNames) ->
    import_resolver_fun_oplist([Arg1, Arg2], FNames);
import_resolver_fun_op({match, _, Arg1, Arg2}, FNames) ->
    import_resolver_fun_oplist([Arg1, Arg2], FNames);
import_resolver_fun_op({call, _, What, Args}, FNames) ->
    [ import_resolver_call(What, length(Args), FNames)
    , import_resolver_fun_oplist(Args, FNames)];
import_resolver_fun_op({'case', _, Op, Clauses}, FNames) ->
    import_resolver_fun_op(Op, FNames) ++ import_resolver_fun_clauses(Clauses, FNames);
import_resolver_fun_op({'try', _, Body, Clauses, CatchClauses, After}, FNames) ->
    [ import_resolver_fun_oplist(Body, FNames)
    , import_resolver_fun_oplist(After, FNames)
    , import_resolver_fun_clauses(Clauses, FNames)
    , import_resolver_fun_clauses(CatchClauses, FNames)
    ];
import_resolver_fun_op({bc, _, Bin, Generators}, FNames) ->
    [ import_resolver_fun_op(Bin, FNames)
    , import_resolver_fun_oplist(Generators, FNames)
    ];
import_resolver_fun_op({cons, _, Head, Tail}, FNames) ->
    import_resolver_fun_oplist([Head, Tail], FNames);
import_resolver_fun_op({record, _, _, RecordFields}, FNames) ->
    import_resolver_fun_oplist([Op || {record_field, _, _, Op} <- RecordFields], FNames);
import_resolver_fun_op({generate, _, P, E}, FNames) ->
    import_resolver_fun_oplist([P, E], FNames);
import_resolver_fun_op(Op, _) ->
    io:format("~p\n", [Op]).

%% Determine what module we need to import in order to handle this call
import_resolver_call({atom, _, What}, Arity, FNames) ->
    import_resolver_call(undefined, What, Arity, FNames);
import_resolver_call({remote, _, {atom, _, Where}, {atom, _, What}}, Arity, FNames) ->
    import_resolver_call(Where, What, Arity, FNames).

import_resolver_call(undefined, What, Arity, FNames) ->
    %% Check what local are we referencing
    case sets:is_element({atom_to_list(What), Arity}, FNames) of
        true ->
            %% Ok this is a call to a local function in this module
            undefined;
        false ->
            %% io:format("CALLED_LOCAL: ~p\n", [What])
            %% Probably a BIF
            {erlang_bif, What}
    end;
import_resolver_call(Where, What, Arity, _) ->
    case module_polifill(Where) of
        {ok, Module} ->
            %%io:format("CALLED_REMOTE: ~p\n", [Module]),
            {Module, What};
        unknown ->
            erlscripten_logger:debug("Assuming transpiled purescript module: ~p", [Where]),
            {Where, What}
    end.

module_polifill(erlang) -> {ok, erlang_bif};
module_polifill(binary) -> {ok, erlang_binary};
module_polifill(base58) -> {ok, erlang_base58};
module_polifill(base64) -> {ok, erlang_base64};
module_polifill(crypto) -> {ok, erlang_crypto};
module_polifill(lists) -> {ok, erlang_lists};
module_polifill(_) -> unknown.

transpile_function({{FunName, Arity}, Clauses}, Records, FNames, Handle) ->
    %% Ok time to emit the type for the purescript compiler
    write_line(Handle, 0, "~s :: Partial => ~sEffect ErlangTerm", [FunName, string:copies("ErlangTerm -> ", Arity)]),
    [transpile_function_clause(FunName, Clause, Records, FNames, Handle) || Clause <- Clauses],
    write_line(Handle, 0, "", []).

%% Simplified purescript AST - keep it as simple as possible
-type purs_ast() ::
      {operator, string(), purs_ast(), purs_ast()}
    | {num, number()}
    | {string, string()}
    | {var, string()}
    | {cons, string(), [purs_ast()]}
    | {array, [purs_ast()]}
    | {named_pattern, string(), purs_ast()}.

purs_ast_to_str({operator, Name, Ast1, Ast2}) ->
    io_lib:format("~s ~s ~s", [purs_ast_to_str(Ast1), Name, purs_ast_to_str(Ast2)]);
purs_ast_to_str({num, Number}) ->
    io_lib:format("~p", [Number]);
purs_ast_to_str({string, Str}) ->
    io_lib:format("\"~s\"", [Str]);
purs_ast_to_str({var, Str}) ->
    io_lib:format("~s", [Str]);
purs_ast_to_str({cons, Name, []}) ->
    io_lib:format("(~s)", [Name]);
purs_ast_to_str({cons, Name, Args}) ->
    io_lib:format("(~s ~s)", [Name, string:join([purs_ast_to_str(Arg) || Arg <- Args], " ")]);
purs_ast_to_str({array, Args}) ->
    io_lib:format("[~s]", [string:join([purs_ast_to_str(Arg) || Arg <- Args], ", ")]);
purs_ast_to_str({named_pattern, PatternName, Ast}) ->
    io_lib:format("~s@(~s)", [PatternName, purs_ast_to_str(Ast)]).

transpile_function_clause(FunName, {clause, _, Args, Guards, Body}, Records, FNames, Handle) ->
    %% Ok this will be slightly tricky, some patterns commonly used in erlang function clauses
    %% cannot be expressed as matches in Purescipt BUT we may emulate them in guards!
    %% Guards in purescript are really powerful - using patten guards we will emulate what we want
    %% Now we need to determine 2 important things:
    %% 1) What to match in the function head
    %% 2) What to assert in the guard
    %% We also need to emulate erlang's semantics of matching by value
    %% Important:
    %% 1) Standalone variables are the simplest case to consider
    %% 2) Literal atoms/strings/tuples are easy
    %% 3) Binaries are a PITA
    %% Keeping track of variable bindings in a pure functional way will be a PITA
    %% Let's use the process dictionary to emulate a state monad and then gather results at the end
    %% Only after we emitted the guards which will bring the referenced variables in scope
    %% we may add the guards from erlang :)
    %% When matching by value always create a new variable and AFTER all the guards which
    %% will bring the vars in the proper scope we will assert equality
    %% What essentially we want to generate:
    %% fun_name match1 match2 ... matchN | g_match1, g_match2, ..., g_matchN, ERLANG_MATCH_BY_VALUE, user erlang guard expressions
    %% Some guards which we may emit are in the state monad
    %% To deal with it just emit "unsafePerformEffect" and add guards which will ensure that
    %% The effectful computation won't throw an exception
    %% For instance: when dealing with <<X>> first emit a check for the length and
    %% only then unsafely access the specified byte in the binary
    state_clear_vars(),
    S = [transpile_pattern(Arg, Records) || Arg <- Args, is_tuple(Arg)],
    PSArgs = [A || {A, _, _} <- S],
    %% First the guards which will create the variable bindings
    %% Then the guards which will ensure term equality
    PsGuards = lists:flatten([G || {_, G, _} <- S]) ++ lists:flatten([G || {_, _, G} <- S]),
    erlscripten_logger:debug("GUARD: ~p", [Guards]),
    write_line(Handle, 0, "~s ~s~s = do", [FunName, format_fun_args(PSArgs), format_fun_guards(PsGuards)]).

format_fun_args(Args) ->
    string:join([purs_ast_to_str(Arg) || Arg <- Args], " ").
format_fun_guards([]) ->
    "";
format_fun_guards(Guards) ->
    io_lib:format(" | ~s", [string:join([purs_ast_to_str(G) || G <- Guards], ", ")]).

ps_cons(Name) -> {cons, Name, []}.
ps_cons(Name, Args) -> {cons, Name, Args}.
ps_string(String) -> {string, String}.
ps_var(Name) -> {var, Name}.
ps_erl_atom(Atom) -> ps_cons("ErlangAtom", [ps_string(Atom)]).
ps_erl_num(Ast) -> ps_cons("ErlangNum", [Ast]).
ps_bin_op(Arg1, Op, Arg2) -> {operator, Op, Arg1, Arg2}.
ps_named_pattern(Name, Ast) -> {named_pattern, Name, Ast}.

%% An erlang pattern can always be compiled to a purescript pattern and a list of guards
%% Returns {match, g_match, values_eq}
%% match is an purescript pattern, g_match are the pattern guards which will bring the
%% necessary bindings to the appropriate scope, values_eq ensure erlang term equality
%% for cosmetic reasons values_eq are aggregated and evaluated only after all g_match got executed
%% https://erlang.org/doc/apps/erts/absform.html#patterns
%% Atomic Literals
transpile_pattern({atom, _, Atom}, _) ->
    {ps_erl_atom(Atom), [], []};
transpile_pattern({char, _, Char}, _) ->
    error(todo);
transpile_pattern({float, _, Float}, _) ->
    error(todo);
transpile_pattern({op, _, "-", {float, Ann, Num}}, Records) ->
    transpile_pattern({float, Ann, -Num}, Records);
transpile_pattern({integer, _, Num}, _) when Num =< 9007199254740000, Num >= -9007199254740000 ->
    Var = state_create_fresh_var(),
    {ps_named_pattern(Var, ps_erl_num(ps_var("_"))), [ps_bin_op(ps_var(Var), "==", ps_cons("ErlangNum.fromInt", [{num, Num}]))], []};
transpile_pattern({integer, _, Num}, _) ->
    Var = state_create_fresh_var(),
    {ps_named_pattern(Var, ps_erl_num(ps_var("_"))), [ps_bin_op(ps_var(Var), "==", ps_cons("ErlangNum.fromString", [{string, integer_to_list(Num)}]))], []};
transpile_pattern({op, _, "-", {integer, Ann, Num}}, Records) ->
    transpile_pattern({integer, Ann, -Num}, Records);
transpile_pattern({string, _, Str}, _) ->
    {ps_string(Str), [], []};

%% Bitstring pattern
transpile_pattern({bin, _, [{bin_element, _, {string, _, Str}, default, default}]}, _) ->
    %% Binary string literal
    %% Assert buffer length and then compare with str
    Var = state_create_fresh_var(),
    {{named_pattern, Var, {cons, "ErlangBinary", [{var, "_"}]}}, [
        {operator, "==", {num, length(Str)}, {cons, "ErlangBinary.byte_size", [{var, Var}]}},
        {cons, "ErlangBinary.strcmp", [{var, Var}, {string, Str}]}
    ], []};
transpile_pattern({bin, _, []}, _) ->
    %% Empty binary - guard for size eq 0
    Var = state_create_fresh_var(),
    {{named_pattern, Var, {cons, "ErlangBinary", [{var, "_"}]}}, [
        {operator, "==", {num, 0}, {cons, "ErlangBinary.byte_size", [{var, Var}]}}
    ], []};

%% Compound pattern
transpile_pattern({match, _, P1, P2}, Records) ->
    {H1, G1, V1} = transpile_pattern(P1, Records),
    {H2, G2, V2} = transpile_pattern(P2, Records),
    Var = state_create_fresh_var(),
    {ps_named_pattern(Var, H2), [ps_bin_op(H1, "<-", ps_var(Var))] ++ G1 ++ G2, V1 ++ V2};

%% Cons pattern
transpile_pattern({cons, _, Head, Tail}, Records) ->
    error(todo);

%% Map pattern
transpile_pattern({map, _, Associations}, Records) ->
    error(todo);

%% Nil pattern
transpile_pattern({nil, _}, Records) ->
    error(todo);

%% Operator pattern
transpile_pattern({op, _, Op, P1, P2}, Records) ->
    %% this is either an occurrence of ++ applied to a literal string or character list,
    %% or an occurrence of an expression that can be evaluated to a number at compile time
    error(todo);
transpile_pattern({op, _, Op, P1}, Records) ->
    %% this is an occurrence of an expression that can be evaluated to a number at compile time
    error(todo);

%% Record index pattern
transpile_pattern({record_index, _, RecordName, Field}, Records) ->
    error(todo);

%% Record pattern
transpile_pattern({record, Ann, RecordName, RecordFields}, Records) ->
    %% Convert this to a tuple
    Matches = [record_fields(X) || X <- RecordFields],
    Fields = [{atom, Ann, RecordName}] ++ [proplists:get_value(FieldName, Matches, {var, Ann, "_"}) || {FieldName, _} <- maps:get(RecordName, Records)],
    transpile_pattern({tuple, Ann, Fields}, Records);

%% Tuple pattern
transpile_pattern({tuple, _, Args}, Records) ->
    S = [transpile_pattern(Arg, Records) || Arg <- Args, is_tuple(Arg)],
    PSArgs = [A || {A, _, _} <- S],
    PsVarGuards = lists:flatten([G || {_, G, _} <- S]),
    PsValGuards = lists:flatten([G || {_, _, G} <- S]),
    {{cons, "ErlangTuple", [{array, PSArgs}]}, PsVarGuards, PsValGuards};

%% Universal pattern
transpile_pattern({var, _, [$_|_]}, _) ->
    {ps_var("_"), [], []};

%% Variable pattern
transpile_pattern({var, _, ErlangVar}, _) ->
    Var = state_get_unused_var_name(),
    case state_is_used(ErlangVar) of
        false ->
            state_put_var(ErlangVar, Var),
            {ps_var(Var), [], []};
        true ->
            %% Variable was used before so emit an extra guard
            state_put_var(Var, Var),
            {ps_var(Var), [], [ps_bin_op(ps_var(Var), "==", ps_var(state_get_var(ErlangVar)))]}
    end;

transpile_pattern(Arg, _Records) ->
    erlscripten_logger:debug("~p", [Arg]),
    {ps_var("TODO"), [], []}.

%% Hacky emulation of a state monad using the process dictionary :P
-define(BINDINGS, var_bindings).
state_clear_vars() ->
    put(?BINDINGS, #{}).
state_get_vars() ->
    get(?BINDINGS).
state_get_unused_var_name() ->
    "v" ++ integer_to_list(map_size(state_get_vars())).
state_put_var(ErlangVar, PsVar) ->
    put(?BINDINGS, maps:put(ErlangVar, PsVar, state_get_vars())).
state_create_fresh_var() ->
    Var = state_get_unused_var_name(),
    state_put_var(Var, Var),
    Var.
state_is_used(ErlangVar) ->
    maps:is_key(ErlangVar, state_get_vars()).
state_get_var(ErlangVar) ->
    maps:get(ErlangVar, state_get_vars()).
