-module(erlscripten).
-author("gorbak25").

-export([parse_transform/2]).
-export([version/0]).

-include("erlps_purescript.hrl").

version() -> "v0.0.1".


parse_transform(Forms, Options) ->
    code:ensure_loaded(erlscripten_logger),
    application:ensure_started(erlscripten),
    Attributes = [X || X <- lists:map(fun filter_module_attributes/1, Forms), is_tuple(X)],
    FileName = proplists:get_value(file, Attributes),
    try
        ModuleName = proplists:get_value(module, Attributes),
        erlscripten_logger:info("Transpiling ~s", [ModuleName]),
        case proplists:get_value(erlscripten_output, Attributes) of
            undefined ->
                erlscripten_logger:die(FileName,
                    "Please add `-erlscripten_output(DIRECTORY).`"
                    " to indicate where the autogenerated spago project will be placed\n");
            Dir ->
                [BasePath | _] = string:split(proplists:get_value(outdir, Options), "_build"),
                OutDir = filename:join(BasePath, Dir),
                generate_template(OutDir),
                SrcDir = filename:join(OutDir, "src"),
                %% Ok now let's do some preliminary work before starting the conversion
                %% Gather record types
                Records = maps:from_list(proplists:get_all_values(record, Attributes)),
                %% Create the Purescript module
                PursModuleFile = filename:join(SrcDir, erlang_module_to_purs_file(ModuleName)),
                file:delete(PursModuleFile),
                {ok, Handle} = file:open(PursModuleFile, [write]),

                %% Ok It's time for some canonical imports which will be used a lot :)
                DefaultImports = [
                    #import{path = ["Prelude"]},
                    #import{path = ["Erlang", "Type"], explicit = ["ErlangTerm(..)"]}
                    #import{path = ["Effect"], explicit = ["Effect"]}
                ],
                %% Now it's time to determine what modules to import
                %% First filter out functions to transpile
                FunctionForms = [X || X <- lists:map(fun filter_function_forms/1, Forms), is_tuple(X)],
                FunctionNames = sets:from_list([Name || {Name, _} <- FunctionForms]),
                %% Now walk the entire AST and search for calls/remote_calls
                Calls = lists:usort([X || X <- lists:flatten([import_resolver_fun_clauses(X, FunctionNames) || {_, X} <- FunctionForms]), X /= undefined]),
                erlscripten_logger:debug("Module calls: ~p", [Calls]),
                Imports = [#import{
                    path = [erlang_module_to_purs_module(Import)],
                    alias = erlang_module_to_qualified_import(Import)
                } || Import <- lists:usort([M || {M, _} <- Calls])],
                %% Now do the dirty work - transpile every function OwO
                Decls = [Decl ||
                    Function <- FunctionForms,
                    {TypeDecl, Clauses} <- [transpile_function(Function, Records)],
                    Decl <- [TypeDecl | Clauses]
                ],
                Dispatchers = [#top_clause{clause = Disp}
                    || Disp <- make_dispatchers(FunctionForms)],
                Module = #module{
                    name = erlang_module_to_purs_module(ModuleName),
                    imports = DefaultImports ++ Imports,
                    decls = Decls ++ Dispatchers
                },
                file:write(Handle, erlps_purescript:purs_module_to_str(Module))
        end,
        Forms
    catch Error:Reason:StackTrace ->
        erlscripten_logger:die(FileName,
            io_lib:format("Error: ~s\nReason: ~p\nStacktrace: ~p\n", [atom_to_list(Error), Reason, StackTrace])
        )
    end.

filter_module_attributes({attribute, _, file, {Filename, _}}) -> {file, Filename};
filter_module_attributes({attribute, _, module, Module}) when is_atom(Module) -> {module, atom_to_list(Module)};
filter_module_attributes({attribute, _, export, Exports}) -> {export, Exports};
filter_module_attributes({attribute, _, record, {RecordName, RecordFields}}) ->
    {record, {RecordName, lists:map(fun record_fields/1, RecordFields)}};
filter_module_attributes({attribute, _, erlscripten_output, Directory}) when is_atom(Directory) ->
    {erlscripten_output, atom_to_list(Directory)};
filter_module_attributes({attribute, _, erlscripten_output, Directory}) when is_binary(Directory) ->
    {erlscripten_output, binary_to_list(Directory)};
filter_module_attributes({attribute, _, erlscripten_output, Directory}) when is_list(Directory) ->
    {erlscripten_output, Directory};
filter_module_attributes(_) -> undefined.

record_fields({record_field, _, {atom, N, FieldName}}) -> {FieldName, {atom, N, undefined}};
record_fields({record_field, _, {atom, _, FieldName}, Default}) -> {FieldName, Default};
record_fields({typed_record_field, RecordField, _}) -> record_fields(RecordField).

generate_template(DestDir) ->
    SupportDir = filename:join(code:priv_dir(erlscripten), "support"),
    copy_recursive(SupportDir, DestDir).

copy_recursive(Source, Dest) ->
    case filelib:is_dir(Source) of
        true ->
            case filelib:is_dir(Dest) of
                false ->
                    file:make_dir(Dest);
                true ->
                    ok
            end,
            {ok, Names} = file:list_dir(Source),
            [copy_recursive(filename:join(Source, Name), filename:join(Dest, Name)) || Name <- Names];
        false ->
            file:copy(Source, Dest)
    end.

-spec erlang_module_to_purs_module(string() | atom()) -> string().
erlang_module_to_purs_module(Name) when is_atom(Name) ->
    erlang_module_to_purs_module(atom_to_list(Name));
erlang_module_to_purs_module(Name) ->
    string:join(lists:map(fun string:titlecase/1, string:split(Name, "_", all)), ".").

-spec erlang_module_to_qualified_import(string() | atom()) -> string().
erlang_module_to_qualified_import(Name) when is_atom(Name) ->
    erlang_module_to_qualified_import(atom_to_list(Name));
erlang_module_to_qualified_import(Name) ->
    string:join(lists:map(fun string:titlecase/1, string:split(Name, "_", all)), "").

-spec erlang_module_to_purs_file(string() | atom()) -> string().
erlang_module_to_purs_file(Name) when is_atom(Name) ->
    erlang_module_to_purs_file(atom_to_list(Name));
erlang_module_to_purs_file(Name) ->
    string:join(lists:map(fun string:titlecase/1, string:split(Name, "_", all)), "") ++ ".purs".

filter_function_forms({function, _, FunName, Arity, Clauses}) ->
    {{atom_to_list(FunName), Arity}, Clauses};
filter_function_forms(_) ->
    undefined.

import_resolver_fun_clauses(Clauses, FNames) ->
    [import_resolver_fun_clause(X, FNames) || X <- Clauses].
import_resolver_fun_clause({clause, _, _Args, Guards, Body}, FNames) ->
    [[import_resolver_fun_oplist(Guard, FNames) || Guard <- Guards]
        , [import_resolver_fun_oplist(Body, FNames)]].

import_resolver_fun_oplist(Ops, FNames) ->
    [import_resolver_fun_op(Op, FNames) || Op <- Ops].

import_resolver_fun_op({atom, _, _}, _) -> undefined;
import_resolver_fun_op({integer, _, _}, _) -> undefined;
import_resolver_fun_op({string, _, _}, _) -> undefined;
import_resolver_fun_op({var, _, _}, _) -> undefined;
import_resolver_fun_op({nil, _}, _) -> undefined;
import_resolver_fun_op({bin, _, BinElements}, FNames) ->
    import_resolver_fun_oplist([Op || {bin_element, _, Op, _, _} <- BinElements], FNames);
import_resolver_fun_op({tuple, _, Ops}, FNames) ->
    import_resolver_fun_oplist(Ops, FNames);
import_resolver_fun_op({op, _, _, Arg1, Arg2}, FNames) ->
    import_resolver_fun_oplist([Arg1, Arg2], FNames);
import_resolver_fun_op({match, _, Arg1, Arg2}, FNames) ->
    import_resolver_fun_oplist([Arg1, Arg2], FNames);
import_resolver_fun_op({call, _, What, Args}, FNames) ->
    [import_resolver_call(What, length(Args), FNames)
        , import_resolver_fun_oplist(Args, FNames)];
import_resolver_fun_op({'case', _, Op, Clauses}, FNames) ->
    import_resolver_fun_op(Op, FNames) ++ import_resolver_fun_clauses(Clauses, FNames);
import_resolver_fun_op({'try', _, Body, Clauses, CatchClauses, After}, FNames) ->
    [import_resolver_fun_oplist(Body, FNames)
        , import_resolver_fun_oplist(After, FNames)
        , import_resolver_fun_clauses(Clauses, FNames)
        , import_resolver_fun_clauses(CatchClauses, FNames)
    ];
import_resolver_fun_op({bc, _, Bin, Generators}, FNames) ->
    [import_resolver_fun_op(Bin, FNames)
        , import_resolver_fun_oplist(Generators, FNames)
    ];
import_resolver_fun_op({cons, _, Head, Tail}, FNames) ->
    import_resolver_fun_oplist([Head, Tail], FNames);
import_resolver_fun_op({record, _, _, RecordFields}, FNames) ->
    import_resolver_fun_oplist([Op || {record_field, _, _, Op} <- RecordFields], FNames);
import_resolver_fun_op({generate, _, P, E}, FNames) ->
    import_resolver_fun_oplist([P, E], FNames);
import_resolver_fun_op(Op, _) ->
    io:format("~p\n", [Op]).

%% Determine what module we need to import in order to handle this call
import_resolver_call({atom, _, What}, Arity, FNames) ->
    import_resolver_call(undefined, What, Arity, FNames);
import_resolver_call({remote, _, {atom, _, Where}, {atom, _, What}}, Arity, FNames) ->
    import_resolver_call(Where, What, Arity, FNames).

import_resolver_call(undefined, What, Arity, FNames) ->
    %% Check what local are we referencing
    case sets:is_element({atom_to_list(What), Arity}, FNames) of
        true ->
            %% Ok this is a call to a local function in this module
            undefined;
        false ->
            %% io:format("CALLED_LOCAL: ~p\n", [What])
            %% Probably a BIF
            {erlang_bif, What}
    end;
import_resolver_call(Where, What, Arity, _) ->
    case module_polifill(Where) of
        {ok, Module} ->
            %%io:format("CALLED_REMOTE: ~p\n", [Module]),
            {Module, What};
        unknown ->
            erlscripten_logger:debug("Assuming transpiled purescript module: ~p", [Where]),
            {Where, What}
    end.

module_polifill(erlang) -> {ok, erlang_bif};
module_polifill(binary) -> {ok, erlang_binary};
module_polifill(base58) -> {ok, erlang_base58};
module_polifill(base64) -> {ok, erlang_base64};
module_polifill(crypto) -> {ok, erlang_crypto};
module_polifill(lists) -> {ok, erlang_lists};
module_polifill(_) -> unknown.

transpile_function({{FunName, Arity}, Clauses}, Records) ->
    Type = lists:foldr(
        fun(_, R) -> #type_fun{arg = #type_var{name = "ErlangTerm"}, ret = R} end,
        #type_app{typeconstr = #type_var{name = "Effect"}, args = [#type_var{name = "ErlangTerm"}]},
        lists:seq(1, Arity)),
    PSClauses = [#top_clause{clause = transpile_function_clause(FunName, Clause, Records)} ||
        Clause <- Clauses],
    {#top_typedecl{
        typedecl = #typedecl{name = transpile_fun_name(FunName, Arity),
            type = Type}}, PSClauses}.

transpile_fun_name(Name, Arity) when is_atom(Name) ->
    transpile_fun_name(atom_to_list(Name), Arity);
transpile_fun_name(Name, Arity) when is_binary(Name) ->
    transpile_fun_name(binary_to_list(Name), Arity);
transpile_fun_name(Name, Arity) ->
    io_lib:format("~s''~p", [Name, Arity]).

-spec make_dispatcher_name(string()) -> string().
make_dispatcher_name(Name) ->
    Name ++ "''dispatch".

make_dispatcher_for(Name, Arities) ->
    #clause{
        name = make_dispatcher_name(Name),
        args = [#pat_var{name = "args"}],
        value = #expr_case{
            expr = #expr_var{name = "args"},
            cases = [{
                lists:foldr(
                    fun(I, Acc) ->
                        #pat_constr{
                            constr = "ErlangCons",
                            args = [#pat_var{name = io_lib:format("arg_~p", [I])}, Acc]}
                    end,
                    #pat_constr{constr = "ErlangEmptyList", args = []},
                    lists:seq(1, Arity)),
                [], % guards
                #expr_app{
                    function = #expr_var{name = transpile_fun_name(Name, Arity)},
                    args = [#expr_var{name = io_lib:format("arg_~p", [I])}
                        || I <- lists:seq(1, Arity)]}}
                || Arity <- Arities
            ]
        }
    }.

make_dispatchers(Functions) ->
    ArityMap = lists:foldr(
        fun({K, V}, D) -> dict:append(K, V, D) end,
        dict:new(),
        [{Name, Arity} || {{Name, Arity}, _} <- Functions]),
    ArityMapList = dict:to_list(ArityMap),
    Global = make_global_dispatcher([Name || {Name, _} <- ArityMapList]),
    [make_dispatcher_for(Fun, Arities)
        || {Fun, Arities} <- ArityMapList
    ] ++ [Global].

global_dispatcher_name() ->
    "main_dispatcher''".

make_global_dispatcher(FunNames) ->
    #clause{
        name = global_dispatcher_name(),
        args = [#pat_var{name = "function"}, #pat_var{name = "args"}],
        value = #expr_case{
            expr = #expr_var{name = "function"},
            cases = [{
                #pat_string{value = Fun},
                [], % guards
                #expr_app{
                    function = #expr_var{name = make_dispatcher_name(Fun)},
                    args = [#expr_var{name = "args"}]
                }}
                || Fun <- FunNames
            ]
        }
    }.

transpile_function_clause(FunName, {clause, _, Args, Guards, Body}, Records) ->
    %% Ok this will be slightly tricky, some patterns commonly used in erlang function clauses
    %% cannot be expressed as matches in Purescipt BUT we may emulate them in guards!
    %% Guards in purescript are really powerful - using patten guards we will emulate what we want
    %% Now we need to determine 2 important things:
    %% 1) What to match in the function head
    %% 2) What to assert in the guard
    %% We also need to emulate erlang's semantics of matching by value
    %% Important:
    %% 1) Standalone variables are the simplest case to consider
    %% 2) Literal atoms/strings/tuples are easy
    %% 3) Binaries are a PITA
    %% Keeping track of variable bindings in a pure functional way will be a PITA
    %% Let's use the process dictionary to emulate a state monad and then gather results at the end
    %% Only after we emitted the guards which will bring the referenced variables in scope
    %% we may add the guards from erlang :)
    %% When matching by value always create a new variable and AFTER all the guards which
    %% will bring the vars in the proper scope we will assert equality
    %% What essentially we want to generate:
    %% fun_name match1 match2 ... matchN | g_match1, g_match2, ..., g_matchN, ERLANG_MATCH_BY_VALUE, user erlang guard expressions
    %% Some guards which we may emit are in the state monad
    %% To deal with it just emit "unsafePerformEffect" and add guards which will ensure that
    %% The effectful computation won't throw an exception
    %% For instance: when dealing with <<X>> first emit a check for the length and
    %% only then unsafely access the specified byte in the binary
    state_clear_vars(),
    state_clear_var_stack(),
    {PsArgs, PsGuards} = transpile_pattern_sequence(Args, Records),
    #clause{
        name = transpile_fun_name(FunName, length(Args)),
        args = PsArgs,
        guards = [#guard_expr{guard = transpile_expr(G, Records)} || G <- Guards] ++ PsGuards,
        value = transpile_expr(Body, Records)
    }.


transpile_pattern_sequence(PatternSequence, Records) ->
    state_push_var_stack(), %% Push fully bound variables
    S = [transpile_pattern(Pattern, Records) || Pattern <- PatternSequence, is_tuple(Pattern)],
    PSArgs = [A || {A, _, _} <- S],
    %% First the guards which will create the variable bindings
    %% Then the guards which will ensure term equality
    PsGuards = lists:flatten([G || {_, G, _} <- S]) ++ lists:flatten([G || {_, _, G} <- S]),
    {PSArgs, PsGuards}.

%% An erlang pattern can always be compiled to a purescript pattern and a list of guards
%% Returns {match, g_match, values_eq}
%% match is an purescript pattern, g_match are the pattern guards which will bring the
%% necessary bindings to the appropriate scope, values_eq ensure erlang term equality
%% for cosmetic reasons values_eq are aggregated and evaluated only after all g_match got executed
%% https://erlang.org/doc/apps/erts/absform.html#patterns
%% Atomic Literals
transpile_pattern({atom, _, Atom}, _) ->
    {#pat_constr{constr = "ErlangAtom", args = [#pat_string{value = Atom}]}, [], []};
transpile_pattern({char, _, Char}, _) ->
    error(todo);
transpile_pattern({float, _, Float}, _) ->
    error(todo);
transpile_pattern({integer, _, Num}, _) when Num =< 9007199254740000, Num >= -9007199254740000 ->
    error({todo, too_big_int});
transpile_pattern({integer, _, Num}, _) ->
    #pat_num{value = Num};
transpile_pattern({op, _, "-", {integer, Ann, Num}}, Records) ->
    transpile_pattern({integer, Ann, -Num}, Records);

%% Bitstring pattern
transpile_pattern({bin, _, []}, _) ->
    %% The easy case – <<>>
    %% Empty binary - guard for size eq 0
    Var = state_create_fresh_var(),
    {{#pat_constr{constr = "ErlangBinary", args = [#pat_var{name = Var}]}}, [
        #guard_expr{guard =
        #expr_binop{
            name = "==",
            lop = #expr_num{value = 0},
            rop = #expr_app{function = "ErlangBinary.unboxed_byte_size", args = [#expr_var{name = Var}]}}}
    ], []};
transpile_pattern({bin, _, [{bin_element, _, {string, _, Str}, default, default}]}, _) ->
    %% Binary string literal – <<"erlang">>
    %% Assert buffer length and then compare with str
    Var = state_create_fresh_var(),
    {{#pat_constr{constr = "ErlangBinary", args = [#pat_var{name = Var}]}}, [
        #guard_expr{guard = #expr_binop{
            name = "==",
            lop = #expr_num{value = length(Str)},
            rop = #expr_app{function = "ErlangBinary.unboxed_byte_size", args = [#expr_var{name = Var}]}}},
        #guard_expr{guard = #expr_binop{
            name = "==",
            lop = #expr_num{value = length(Str)},
            rop = #expr_app{function = "ErlangBinary.unboxed_strcmp", args = [#expr_var{name = Var}, #expr_string{value = Str}]}}}
    ], []};
transpile_pattern({bin, _, Segments}, _) ->
    %% Ok the general hard part...
    %% Unfortunately we need to keep track of bindings created in this match
    %% Variables in the size guard can only reference variables from the enclosing scope
    %% present on the variable stack OR variables created during this binding
    %% Fortunately patterns can only be literals or variables
    %% Size specs are guard expressions
    Var = state_create_fresh_var(),
    {G, V, _} = transpile_binary_pattern_segments(Var, Segments, #{}),
    {#pat_constr{constr = "ErlangBinary", args = [#pat_var{name = Var}]}, G, V};
%% Compound pattern
transpile_pattern({match, _, P1, P2}, Records) ->
    {H1, G1, V1} = transpile_pattern(P1, Records),
    {H2, G2, V2} = transpile_pattern(P2, Records),
    Var = state_create_fresh_var(),
    {#pat_as{name = Var, pattern = H2},
        [#guard_assg{lvalue = H1, rvalue = #expr_var{name = Var}} | G1 ++ G2], V1 ++ V2};

%% Cons pattern
transpile_pattern({cons, _, Head, Tail}, Records) ->
    {H, GH, VH} = transpile_pattern(Head, Records),
    {T, GT, VT} = transpile_pattern(Tail, Records),
    {#pat_constr{constr = "ErlangCons", args = [H, T]}, GH ++ GT, VH ++ VT};

%% Map pattern
transpile_pattern({map, _, Associations}, Records) ->
    MapVar = state_create_fresh_var(),
    {G, V} =
        lists:foldl(fun({map_field_exact, _, Key, Value}, {Gs, Vs}) ->
            begin
                {ValPat, GV, VV} = transpile_pattern(Value, Records),
                KeyExpr = transpile_expr(Key, Records),
                QueryGuard = #guard_assg{
                    lvalue = #pat_constr{constr = "Just", args = [ValPat]},
                    rvalue = #expr_app{
                        function = #expr_var{name = "Map.lookup"},
                        args = [KeyExpr, #expr_var{name = MapVar}]}},
                {[QueryGuard | GV ++ Gs], VV ++ Vs}
            end end, {[], []}, Associations),
    {#pat_var{name = MapVar}, G, V};

%% Nil pattern
transpile_pattern({nil, _}, Records) ->
    {#pat_constr{constr = "ErlangEmptyList"}, [], []};

%% Operator pattern
transpile_pattern({op, _, '++', {nil, _}, P2}, Records) ->
    transpile_pattern(P2, Records);
transpile_pattern({op, Ann, '++', {cons, AnnC, H, T}, P2}, Records) ->
    transpile_pattern({cons, AnnC, H, {op, Ann, '++', T, P2}}, Records);
transpile_pattern(P = {op, Ann, Op, P1, P2}, Records) ->
    case compute_constexpr(P) of
        {ok, Res} -> Res;
        error -> error({illegal_operator_pattern, P})
    end;
transpile_pattern({op, _, Op, P1}, Records) ->
    %% this is an occurrence of an expression that can be evaluated to a number at compile time
    error(todo);

%% Record index pattern
transpile_pattern({record_index, _, RecordName, Field}, Records) ->
    error(todo);

%% Record pattern
transpile_pattern({record, Ann, RecordName, RecordFields}, Records) ->
    %% Convert this to a tuple
    Matches = [record_fields(X) || X <- RecordFields],
    Fields = [{atom, Ann, RecordName}] ++
        [proplists:get_value(FieldName, Matches, {var, Ann, "_"}) ||
            {FieldName, _} <- maps:get(RecordName, Records)],
    transpile_pattern({tuple, Ann, Fields}, Records);

%% Tuple pattern
transpile_pattern({tuple, _, Args}, Records) ->
    S = [transpile_pattern(Arg, Records) || Arg <- Args, is_tuple(Arg)],
    PSArgs = [A || {A, _, _} <- S],
    PsVarGuards = lists:flatten([G || {_, G, _} <- S]),
    PsValGuards = lists:flatten([G || {_, _, G} <- S]),
    {#pat_constr{constr = "ErlangTuple", args = PSArgs}, PsVarGuards, PsValGuards};

%% Universal pattern
transpile_pattern({var, _, [$_ | _]}, _) ->
    pat_wildcard;

%% Variable pattern
transpile_pattern({var, _, ErlangVar}, _) ->
    Var = state_get_unused_var_name(),
    case state_is_used(ErlangVar) of
        false ->
            state_put_var(ErlangVar, Var),
            {#pat_var{name = Var}, [], []};
        true ->
            %% Variable was used before so emit an extra guard
            state_put_var(Var, Var),
            {#pat_var{name = Var},
                [],
                [#guard_expr{guard = #expr_binop{
                    name = "==",
                    lop = #expr_var{name = Var},
                    rop = #expr_var{name = state_get_var(ErlangVar)}}}]}
    end;


transpile_pattern(Arg, _Records) ->
    error({unimplemented_pattern, Arg}).

%% When resolving variables in the size spec look to:
%% 1) The outer scope on the stack
%% 2) The newBindings scope
%% 3) If var is present in both scopes then insert a value guard
transpile_binary_pattern_segments(UnboxedVar, [], NewBindings) ->
    ok.

transpile_expr([Single], Records) ->
    transpile_expr(Single, Records);

transpile_expr({atom, _, Atom}, _Records) ->
    #expr_app{function = #expr_var{name = "ErlangAtom"}, args = [#expr_string{value = atom_to_list(Atom)}]};

transpile_expr({var, _, Var}, _Records) ->
    #expr_var{name = state_get_var(Var)};

transpile_expr({op, _, Op, L, R}, Records) ->
    OpFun = case Op of
                '+' -> "erlangPlus";
                '-' -> "erlangMinus";
                '*' -> "erlangMult";
                '/' -> "erlangDiv";
                '/=' -> "(/=)";
                '=/=' -> "(=/=)";
                '==' -> "(==)"; %% FIXME not the same thing
                '=:=' -> "(==)";
                '++' -> "lists:append"
            end,
    LE = transpile_expr(L, Records),
    RE = transpile_expr(R, Records),
    #expr_app{function = #expr_var{name = OpFun}, args = [LE, RE]};

transpile_expr({call, _, {atom, _, Fun}, Args}, Records) ->
    FunName = transpile_fun_name(Fun, length(Args)),
    #expr_app{
        function = #expr_var{name = FunName},
        args = [transpile_expr(Arg, Records) || Arg <- Args]
    };
transpile_expr({call, _, {atom, _, Fun}, Args}, Records) ->
    FunName = transpile_fun_name(Fun, length(Args)),
    #expr_app{
        function = #expr_var{name = FunName},
        args = [transpile_expr(Arg, Records) || Arg <- Args]
    };

transpile_expr(X, _Records) ->
    error({unimplemented_expr, X}).

compute_constexpr({op, _, Op, L, R}) -> %% FIXME: float handling needs to be fixed
    case {compute_constexpr(L), compute_constexpr(R)} of
        {{ok, LV}, {ok, RV}}
            when is_number(LV) andalso is_number(RV) andalso
            (Op =:= '+' orelse Op =:= '-' orelse Op =:= '*' orelse Op =:= '/')
            -> {ok, (fun erlang:Op/2)(LV, RV)};
        _ -> error
    end;
compute_constexpr({integer, _, Num}) ->
    {ok, Num};
compute_constexpr({float, _, Num}) ->
    {ok, Num}.

%% Hacky emulation of a state monad using the process dictionary :P
-define(BINDINGS, var_bindings).
-define(BINDINGS_STACK, var_bindings_stack).
%% Variable bindings
state_clear_vars() ->
    put(?BINDINGS, #{}).
state_get_vars() ->
    get(?BINDINGS).
state_get_unused_var_name() ->
    "v" ++ integer_to_list(map_size(state_get_vars())).
state_put_var(ErlangVar, PsVar) ->
    put(?BINDINGS, maps:put(ErlangVar, PsVar, state_get_vars())).
state_create_fresh_var() ->
    Var = state_get_unused_var_name(),
    state_put_var(Var, Var),
    Var.
state_is_used(ErlangVar) ->
    maps:is_key(ErlangVar, state_get_vars()).
state_get_var(ErlangVar) ->
    maps:get(ErlangVar, state_get_vars()).
%% Bindings stack
state_clear_var_stack() ->
    put(?BINDINGS_STACK, []).
state_push_var_stack() ->
    put(?BINDINGS_STACK, [state_get_vars() | get(?BINDINGS_STACK)]).
state_pop_var_stack() ->
    put(?BINDINGS_STACK, tl(get(?BINDINGS_STACK))).
state_peek_var_stack() ->
    hd(get(?BINDINGS_STACK)).
