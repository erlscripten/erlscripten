-module(erlscripten).
-author("gorbak25").

-export([parse_transform/2]).

version() -> "v0.0.1".

parse_transform(Forms, Options) ->
    code:ensure_loaded(erlscripten_logger),
    application:ensure_started(erlscripten),
    Attributes = [X || X <- lists:map(fun filter_module_attributes/1, Forms), is_tuple(X)],
    FileName = proplists:get_value(file, Attributes),
    try
        ModuleName = proplists:get_value(module, Attributes),
        erlscripten_logger:info("Transpiling ~s", [ModuleName]),
        case proplists:get_value(erlscripten_output, Attributes) of
            undefined ->
                erlscripten_logger:die(FileName, "Please add -erlscripten_output(DIRECTORY). To indicate where the autogenerated spago project will be placed\n");
            Dir ->
                [BasePath|_] = string:split(proplists:get_value(outdir, Options), "_build"),
                OutDir = filename:join(BasePath, Dir),
                generate_template(OutDir),
                SrcDir = filename:join(OutDir, "src"),
                %% Ok now let's do some preliminary work before starting the conversion
                %% Gather record types
                Records = maps:from_list(proplists:get_all_values(record, Attributes)),
                %% Create the Purescript module
                PursModuleFile = filename:join(SrcDir, erlang_module_to_purs_file(ModuleName)),
                file:delete(PursModuleFile),
                {ok, Handle} = file:open(PursModuleFile, [write]),
                write_line(Handle, 0, "module ~s where", [erlang_module_to_purs_module(ModuleName)]),
                write_line(Handle, 0, "{-", []),
                write_lines(Handle, 1, [
                    {"This file has been autogenerated", []},
                    {"DO NOT EDIT - Your changes WILL be overwritten", []},
                    {"Use this code at your own risk - the author is just a mischievous raccoon", []},
                    {"Erlscripten ~s", [version()]}
                ]),
                write_line(Handle, 0, "-}", []),
                write_line(Handle, 0, "", []),
                %% Ok It's time for some canonical imports :)
                write_lines(Handle, 0, [
                    {"import Prelude", []},
                    {"import Erlang.Type (ErlangTerm(..))", []}
                ]),
                %% Now it's time to determine what modules to import
                %% First filter out functions to transpile
                FunctionForms = [X || X <- lists:map(fun filter_function_forms/1, Forms), is_tuple(X)],
                FunctionNames = sets:from_list([Name || {Name, _} <- FunctionForms]),
                %% Now walk the entire AST and search for calls/remote_calls
                Calls = lists:usort([X || X <- lists:flatten([import_resolver_fun_clauses(X, FunctionNames) || {_, X} <- FunctionForms]), X /= undefined]),
                io:format("Module calls: ~p\n", [Calls]),
                Imports = lists:usort([M || {M, _} <- Calls]),
                [write_line(Handle, 0, "import ~s as ~s", [erlang_module_to_purs_module(Import), erlang_module_to_qualified_import(Import)]) || Import <- Imports]
        end,
        Forms
    catch Error:Reason:StackTrace ->
        erlscripten_logger:die(FileName,
            io_lib:format("Error: ~s\nReason: ~p\nStacktrace: ~p\n", [atom_to_binary(Error), Reason, StackTrace])
        )
    end.

filter_module_attributes({attribute, _, file, {Filename, _}}) -> {file, Filename};
filter_module_attributes({attribute, _, module, Module}) when is_atom(Module) -> {module, atom_to_list(Module)};
filter_module_attributes({attribute, _, export, Exports}) -> {export, Exports};
filter_module_attributes({attribute, _, record, {RecordName, RecordFields}}) -> {record, {RecordName, lists:map(fun record_fields/1, RecordFields)}};
filter_module_attributes({attribute, _, erlscripten_output, Directory}) when is_atom(Directory) -> {erlscripten_output, atom_to_list(Directory)};
filter_module_attributes({attribute, _, erlscripten_output, Directory}) when is_binary(Directory) -> {erlscripten_output, binary_to_list(Directory)};
filter_module_attributes({attribute, _, erlscripten_output, Directory}) when is_list(Directory) -> {erlscripten_output, Directory};
filter_module_attributes(_) -> undefined.

record_fields({record_field, _, {atom, N, FieldName}}) -> {FieldName, {atom, N, undefined}};
record_fields({record_field, _, {atom, _, FieldName}, Default}) -> {FieldName, Default}.

generate_template(DestDir) ->
    SupportDir = filename:join(code:priv_dir(erlscripten), "support"),
    copy_recursive(SupportDir, DestDir).

copy_recursive(Source, Dest) ->
    case filelib:is_dir(Source) of
        true ->
            case filelib:is_dir(Dest) of
                false ->
                    file:make_dir(Dest);
                true ->
                    ok
            end,
            {ok, Names} = file:list_dir(Source),
            [copy_recursive(filename:join(Source, Name), filename:join(Dest, Name)) || Name <- Names];
        false ->
            file:copy(Source, Dest)
    end.

erlang_module_to_purs_module(Name) when is_atom(Name) ->
    erlang_module_to_purs_module(atom_to_list(Name));
erlang_module_to_purs_module(Name) ->
    string:join(lists:map(fun string:titlecase/1, string:split(Name, "_", all)), ".").

erlang_module_to_qualified_import(Name) when is_atom(Name) ->
    erlang_module_to_qualified_import(atom_to_list(Name));
erlang_module_to_qualified_import(Name) ->
    string:join(lists:map(fun string:titlecase/1, string:split(Name, "_", all)), "").

erlang_module_to_purs_file(Name) when is_atom(Name) ->
    erlang_module_to_purs_file(atom_to_list(Name));
erlang_module_to_purs_file(Name) ->
    string:join(lists:map(fun string:titlecase/1, string:split(Name, "_", all)), "") ++ ".purs".

write_lines(Handle, IdentLevel, Lines) ->
    [write_line(Handle, IdentLevel, Format, Args) || {Format, Args} <- Lines].
write_line(Handle, IdentLevel, Format, Args) ->
    file:write(Handle, string:copies("    ", IdentLevel) ++ io_lib:format(Format, Args) ++ "\n").

filter_function_forms({function, _, FunName, Arity, Clauses}) ->
    {{atom_to_list(FunName), Arity}, Clauses};
filter_function_forms(_) ->
    undefined.

import_resolver_fun_clauses(Clauses, FNames) ->
    [import_resolver_fun_clause(X, FNames) || X <- Clauses].
import_resolver_fun_clause({clause, _, _Args, Guards, Body}, FNames) ->
    [import_resolver_fun_oplist(Guard, FNames) || Guard <- Guards]
    ++
    [import_resolver_fun_oplist(Body, FNames)].

import_resolver_fun_oplist(Ops, FNames) ->
    [import_resolver_fun_op(Op, FNames) || Op <- Ops].

import_resolver_fun_op({atom, _, _}, _) -> undefined;
import_resolver_fun_op({integer, _, _}, _) -> undefined;
import_resolver_fun_op({string, _, _}, _) -> undefined;
import_resolver_fun_op({var, _, _}, _) -> undefined;
import_resolver_fun_op({nil, _}, _) -> undefined;
import_resolver_fun_op({bin, _, BinElements}, FNames) ->
    import_resolver_fun_oplist([Op || {bin_element, _, Op, _, _} <- BinElements], FNames);
import_resolver_fun_op({tuple, _, Ops}, FNames) ->
    import_resolver_fun_oplist(Ops, FNames);
import_resolver_fun_op({op, _, _, Arg1, Arg2}, FNames) ->
    import_resolver_fun_oplist([Arg1, Arg2], FNames);
import_resolver_fun_op({match, _, Arg1, Arg2}, FNames) ->
    import_resolver_fun_oplist([Arg1, Arg2], FNames);
import_resolver_fun_op({call, _, What, Args}, FNames) ->
    [ import_resolver_call(What, length(Args), FNames)
    , import_resolver_fun_oplist(Args, FNames)];
import_resolver_fun_op({'case', _, Op, Clauses}, FNames) ->
    import_resolver_fun_op(Op, FNames) ++ import_resolver_fun_clauses(Clauses, FNames);
import_resolver_fun_op({'try', _, Body, Clauses, CatchClauses, After}, FNames) ->
    [ import_resolver_fun_oplist(Body, FNames)
    , import_resolver_fun_oplist(After, FNames)
    , import_resolver_fun_clauses(Clauses, FNames)
    , import_resolver_fun_clauses(CatchClauses, FNames)
    ];
import_resolver_fun_op({bc, _, Bin, Generators}, FNames) ->
    [ import_resolver_fun_op(Bin, FNames)
    , import_resolver_fun_oplist(Generators, FNames)
    ];
import_resolver_fun_op({cons, _, Head, Tail}, FNames) ->
    import_resolver_fun_oplist([Head, Tail], FNames);
import_resolver_fun_op({record, _, _, RecordFields}, FNames) ->
    import_resolver_fun_oplist([Op || {record_field, _, _, Op} <- RecordFields], FNames);
import_resolver_fun_op({generate, _, P, E}, FNames) ->
    import_resolver_fun_oplist([P, E], FNames);
import_resolver_fun_op(Op, _) ->
    io:format("~p\n", [Op]).

%% Determine what module we need to import in order to handle this call
import_resolver_call({atom, _, What}, Arity, FNames) ->
    import_resolver_call(undefined, What, Arity, FNames);
import_resolver_call({remote, _, {atom, _, Where}, {atom, _, What}}, Arity, FNames) ->
    import_resolver_call(Where, What, Arity, FNames).

import_resolver_call(undefined, What, Arity, FNames) ->
    %% Check what local are we referencing
    case sets:is_element({atom_to_list(What), Arity}, FNames) of
        true ->
            %% Ok this is a call to a local function in this module
            undefined;
        false ->
            %% io:format("CALLED_LOCAL: ~p\n", [What])
            %% Probably a BIF
            {erlang_bif, What}
    end;
import_resolver_call(Where, What, Arity, _) ->
    case module_polifill(Where) of
        {ok, Module} ->
            %%io:format("CALLED_REMOTE: ~p\n", [Module]),
            {Module, What};
        unknown ->
            io:format("Asuming transpiled purescript module: ~p\n", [Where]),
            {Where, What}
    end.

module_polifill(erlang) -> {ok, erlang_bif};
module_polifill(binary) -> {ok, erlang_binary};
module_polifill(base58) -> {ok, erlang_base58};
module_polifill(base64) -> {ok, erlang_base64};
module_polifill(crypto) -> {ok, erlang_crypto};
module_polifill(lists) -> {ok, erlang_lists};
module_polifill(_) -> unknown.
