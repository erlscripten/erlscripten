module Factorial(erlps__factorial__1) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__factorial__1 :: ErlangFun
erlps__factorial__1 [n_0] =
  let arg_2 = toErl 1
  in erlps__factorial__2 [n_0, arg_2]
erlps__factorial__1 [arg_3] = EXC.function_clause unit
erlps__factorial__1 args =
  EXC.badarity (ErlangFun 1 erlps__factorial__1) args

erlps__factorial__2 :: ErlangFun
erlps__factorial__2 [(ErlangInt num_0), acc_1]
  | (ErlangInt num_0) == (toErl 0) =
  acc_1
erlps__factorial__2 [n_0, acc_1] =
  let    rop_4 = toErl 1
  in let arg_2 = BIF.erlang__op_minus [n_0, rop_4]
  in let arg_5 = BIF.erlang__op_mult [acc_1, n_0]
  in erlps__factorial__2 [arg_2, arg_5]
erlps__factorial__2 [arg_8, arg_9] = EXC.function_clause unit
erlps__factorial__2 args =
  EXC.badarity (ErlangFun 2 erlps__factorial__2) args