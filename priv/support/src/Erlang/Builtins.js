"use strict";

let ErlangTypes = undefined;
try {
    ErlangTypes = PS["Erlang.Type"]
} catch (e) {
    ErlangTypes = require("../Erlang.Type/index.js")
};
console.log(ErlangTypes.ErlangNum.create(1))
console.log(ErlangTypes.ErlangTuple.create([]))

/* Autogenerated polyfills from the Typescript compiler */
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/* https://github.com/elixirscript/processes */

var process_states = {
    NORMAL: Symbol.for('normal'),
    KILL: Symbol.for('kill'),
    SUSPEND: Symbol.for('suspend'),
    CONTINUE: Symbol.for('continue'),
    RECEIVE: Symbol.for('receive'),
    SEND: Symbol.for('send'),
    SLEEPING: Symbol.for('sleeping'),
    RUNNING: Symbol.for('running'),
    SUSPENDED: Symbol.for('suspended'),
    STOPPED: Symbol.for('stopped'),
    SLEEP: Symbol.for('sleep'),
    EXIT: Symbol.for('exit'),
    NOMATCH: Symbol.for('no_match'),
};

var ProcessQueue = /** @class */ (function () {
    function ProcessQueue(pid) {
        this.pid = pid;
        this.tasks = [];
    }
    ProcessQueue.prototype.empty = function () {
        return this.tasks.length === 0;
    };
    ProcessQueue.prototype.add = function (task) {
        this.tasks.push(task);
    };
    ProcessQueue.prototype.next = function () {
        return this.tasks.shift();
    };
    return ProcessQueue;
}());

/**
 * Default scheduler for the process system.
 * Schedules process execution using setTimeout.
 * The most generic scheduler and maybe not good for
 * anything with dom manipulation.
 */
var DefaultScheduler = /** @class */ (function () {
    function DefaultScheduler(throttle, reductions_per_process) {
        if (throttle === void 0) { throttle = 0; }
        if (reductions_per_process === void 0) { reductions_per_process = 8; }
        this.isRunning = false;
        this.invokeLater = function (callback) {
            setTimeout(callback, throttle);
        };
        // In our case a reduction is equal to a task call
        // Controls how many tasks are called at a time per process
        this.reductions_per_process = reductions_per_process;
        this.queues = new Map();
        this.run();
    }
    DefaultScheduler.prototype.addToQueue = function (pid, task) {
        if (!this.queues.has(pid)) {
            this.queues.set(pid, new ProcessQueue(pid));
        }
        var queue = this.queues.get(pid);
        if (queue) {
            queue.add(task);
        }
    };
    DefaultScheduler.prototype.removePid = function (pid) {
        this.isRunning = true;
        this.queues.delete(pid);
        this.isRunning = false;
    };
    DefaultScheduler.prototype._run = function (run) {
        this.invokeLater(function () {
            run();
        });
    };
    DefaultScheduler.prototype.run = function () {
        var e_1, _a;
        if (this.isRunning) {
            this._run(this.run.bind(this));
        }
        else {
            try {
                for (var _b = __values(this.queues), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), pid = _d[0], queue = _d[1];
                    var reductions = 0;
                    while (queue &&
                        !queue.empty() &&
                        reductions < this.reductions_per_process) {
                        var task = queue.next();
                        this.isRunning = true;
                        var result = void 0;
                        try {
                            if (task) {
                                result = task();
                            }
                        }
                        catch (e) {
                            console.error(e);
                            result = e;
                        }
                        this.isRunning = false;
                        if (result instanceof Error) {
                            throw result;
                        }
                        reductions++;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this._run(this.run.bind(this));
        }
    };
    DefaultScheduler.prototype.addToScheduler = function (pid, task, dueTime) {
        var _this = this;
        if (dueTime === void 0) { dueTime = 0; }
        if (dueTime === 0) {
            this.invokeLater(function () {
                _this.addToQueue(pid, task);
            });
        }
        else {
            setTimeout(function () {
                _this.addToQueue(pid, task);
            }, dueTime);
        }
    };
    DefaultScheduler.prototype.schedule = function (pid, task) {
        this.addToScheduler(pid, function () {
            task();
        });
    };
    DefaultScheduler.prototype.scheduleFuture = function (pid, dueTime, task) {
        this.addToScheduler(pid, function () {
            task();
        }, dueTime);
    };
    return DefaultScheduler;
}());

/**
 * Scheduler for the process system.
 * Uses window.requestAnimationFrame to schedule process execution
 * Good for processes that do a lot of dom manipulation
 */
var RequestAnimationScheduler = /** @class */ (function (_super) {
    __extends(RequestAnimationScheduler, _super);
    function RequestAnimationScheduler(throttle, reductions_per_process) {
        if (throttle === void 0) { throttle = 0; }
        if (reductions_per_process === void 0) { reductions_per_process = 8; }
        return _super.call(this, throttle, reductions_per_process) || this;
    }
    RequestAnimationScheduler.prototype._run = function (run) {
        window.requestAnimationFrame(run);
    };
    return RequestAnimationScheduler;
}(DefaultScheduler));

/**
 * Manages a process's messages.
 * A message is anything sent to the process from another
 * process
 */
var Mailbox = /** @class */ (function () {
    function Mailbox() {
        this.messages = [];
    }
    Mailbox.prototype.deliver = function (message) {
        this.messages.push(message);
        return message;
    };
    Mailbox.prototype.get = function () {
        return this.messages;
    };
    Mailbox.prototype.isEmpty = function () {
        return this.messages.length === 0;
    };
    Mailbox.prototype.removeAt = function (index) {
        this.messages.splice(index, 1);
    };
    return Mailbox;
}());

function is_sleep(value) {
    return Array.isArray(value) && value[0] === process_states.SLEEP;
}
function is_receive(value) {
    return Array.isArray(value) && value[0] === process_states.RECEIVE;
}
function receive_timed_out(value) {
    return value[2] != null && value[2] < Date.now();
}
/**
 * A Process. Represents the basic atomic level of concurrency in the system
 */
var Process = /** @class */ (function () {
    function Process(system, func, args) {
        this.system = system;
        this.func = func;
        this.args = args;
        this.status = process_states.STOPPED;
        this.pid = ErlangTypes.ErlangPID.create(1);
        this.mailbox = new Mailbox();
        this.dict = new Map();
        this.flags = new Map();
        this.monitors = [];
    }
    Process.prototype.start = function () {
        var function_scope = this;
        var machine = this.main();
        this.system.schedule(function () {
            function_scope.system.set_current(function_scope.pid);
            function_scope.run(machine, machine.next());
        }, this.pid);
    };
    Process.prototype.main = function () {
        var retval, e_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    retval = process_states.NORMAL;
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [5 /*yield**/, __values(this.func.apply(null, this.args))];
                case 2:
                    _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    e_1 = _a.sent();
                    console.error(e_1);
                    retval = e_1;
                    return [3 /*break*/, 4];
                case 4:
                    this.system.exit(retval);
                    return [2 /*return*/];
            }
        });
    };
    Process.prototype.process_flag = function (flag, value) {
        var old_value = this.flags.get(flag);
        this.flags.set(flag, value);
        return old_value;
    };
    Process.prototype.is_trapping_exits = function () {
        return (this.flags.has(Symbol.for('trap_exit')) &&
            this.flags.get(Symbol.for('trap_exit')) == true);
    };
    Process.prototype.signal = function (reason) {
        if (reason !== process_states.NORMAL) {
            console.error(reason);
        }
        this.system.remove_proc(this.pid, reason);
    };
    Process.prototype.receive = function (fun) {
        var value = process_states.NOMATCH;
        var messages = this.mailbox.get();
        for (var i = 0; i < messages.length; i++) {
            try {
                value = fun(messages[i]);
                if (value !== process_states.NOMATCH) {
                    this.mailbox.removeAt(i);
                    break;
                }
            }
            catch (e) {
                if (e.constructor.name != 'MatchError') {
                    this.system.exit(e);
                }
            }
        }
        return value;
    };
    Process.prototype.run = function (machine, step) {
        var function_scope = this;
        if (!step.done) {
            var value_1 = step.value;
            if (is_sleep(value_1)) {
                this.system.delay(function () {
                    function_scope.system.set_current(function_scope.pid);
                    function_scope.run(machine, machine.next());
                }, value_1[1]);
            }
            else if (is_receive(value_1) && receive_timed_out(value_1)) {
                var result_1 = value_1[3]();
                this.system.schedule(function () {
                    function_scope.system.set_current(function_scope.pid);
                    function_scope.run(machine, machine.next(result_1));
                });
            }
            else if (is_receive(value_1)) {
                var result_2 = function_scope.receive(value_1[1]);
                if (result_2 === process_states.NOMATCH) {
                    this.system.suspend(function () {
                        function_scope.system.set_current(function_scope.pid);
                        function_scope.run(machine, step);
                    });
                }
                else {
                    this.system.schedule(function () {
                        function_scope.system.set_current(function_scope.pid);
                        function_scope.run(machine, machine.next(result_2));
                    });
                }
            }
            else {
                this.system.schedule(function () {
                    function_scope.system.set_current(function_scope.pid);
                    function_scope.run(machine, machine.next(value_1));
                });
            }
        }
    };
    return Process;
}());

/**
 * Manages all of the processes.
 */
var ProcessSystem = /** @class */ (function () {
    function ProcessSystem(scheduler) {
        if (scheduler === void 0) { scheduler = new DefaultScheduler(5); }
        this.pids = new Map();
        this.mailboxes = new Map();
        this.names = new Map();
        this.links = new Map();
        this.monitors = new Map();
        this.current_process = null;
        this.scheduler = scheduler;
        this.suspended = new Map();
        var process_system_scope = this;
        this.main_process_pid = this.spawn(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, process_system_scope.sleep(Symbol.for('Infinity'))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
        this.set_current(this.main_process_pid);
    }
    ProcessSystem.run = function (fun, args, context) {
        if (context === void 0) { context = null; }
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(fun.constructor.name === 'GeneratorFunction')) return [3 /*break*/, 2];
                    return [5 /*yield**/, __values(fun.apply(context, args))];
                case 1: return [2 /*return*/, _a.sent()];
                case 2: return [4 /*yield*/, fun.apply(context, args)];
                case 3: return [2 /*return*/, _a.sent()];
            }
        });
    };
    /**
     * Starts a process represented by the given generator function
     * @param args Either a generator function or a module, function and arguments
     */
    ProcessSystem.prototype.spawn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var fun = args[0];
            return this.add_proc(fun, [], false, false).pid;
        }
        else {
            var mod = args[0];
            var fun = args[1];
            var the_args = args[2];
            return this.add_proc(mod[fun], the_args, false, false).pid;
        }
    };
    /**
     * Starts a process using the generator function from the specified module
     * @param args Either a generator function or a module, function and arguments
     */
    ProcessSystem.prototype.spawn_link = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var fun = args[0];
            return this.add_proc(fun, [], true, false).pid;
        }
        else {
            var mod = args[0];
            var fun = args[1];
            var the_args = args[2];
            return this.add_proc(mod[fun], the_args, true, false).pid;
        }
    };
    /**
     * links the current process with the process from the given pid
     * @param pid pid of the process to link to
     */
    ProcessSystem.prototype.link = function (pid) {
        var currentProcessPid = this.pid();
        if (currentProcessPid != null) {
            var currentProcessLink = this.links.get(currentProcessPid);
            var IncomingProcessLink = this.links.get(pid);
            if (currentProcessLink && IncomingProcessLink) {
                currentProcessLink.add(pid);
                IncomingProcessLink.add(currentProcessPid);
            }
        }
    };
    /**
     * unlinks the current process from the process from the given pid
     * @param pid pid of the process to link to
     */
    ProcessSystem.prototype.unlink = function (pid) {
        var currentProcessPid = this.pid();
        if (currentProcessPid != null) {
            var currentProcessLink = this.links.get(currentProcessPid);
            var IncomingProcessLink = this.links.get(pid);
            if (currentProcessLink && IncomingProcessLink) {
                currentProcessLink.delete(pid);
                IncomingProcessLink.delete(currentProcessPid);
            }
        }
    };
    /**
     * Spawns a process and then monitors it
     * @param args Either a generator function or a module, function and arguments
     */
    ProcessSystem.prototype.spawn_monitor = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var fun = args[0];
            var process_2 = this.add_proc(fun, [], false, true);
            return [process_2.pid, process_2.monitors[0]];
        }
        else {
            var mod = args[0];
            var fun = args[1];
            var the_args = args[2];
            var process_3 = this.add_proc(mod[fun], the_args, false, true);
            return [process_3.pid, process_3.monitors[0]];
        }
    };
    /**
     * Monitors the given process
     * @param pid pid of the process to link to
     */
    ProcessSystem.prototype.monitor = function (pid) {
        var real_pid = this.pidof(pid);
        var ref = this.make_ref();
        if (this.currentProcess != null) {
            if (real_pid) {
                this.monitors.set(ref, {
                    monitor: this.currentProcess.pid,
                    monitee: real_pid,
                });
                var process_4 = this.pids.get(real_pid);
                if (process_4) {
                    process_4.monitors.push(ref);
                }
                return ref;
            }
            else {
                this.send(this.currentProcess.pid,
                    ErlangTypes.ErlangTuple.create(
                        [ErlangTypes.ErlangAtom.create("DOWN"), ref, pid, real_pid, Symbol.for('noproc')]
                        ));
                return ref;
            }
        }
        return null;
    };
    /**
     * Removes the monitor
     * @param ref Reference to monitor
     */
    ProcessSystem.prototype.demonitor = function (ref) {
        if (this.monitors.has(ref)) {
            this.monitors.delete(ref);
            return true;
        }
        return false;
    };
    /**
     * Sets the current process
     * @param id PID or name of process
     */
    ProcessSystem.prototype.set_current = function (id) {
        var pid = this.pidof(id);
        if (pid) {
            var next = this.pids.get(pid);
            if (next) {
                this.current_process = next;
                if (this.currentProcess) {
                    this.currentProcess.status = process_states.RUNNING;
                }
            }
        }
    };
    ProcessSystem.prototype.add_proc = function (fun, args, linked, monitored) {
        var newproc = new Process(this, fun, args);
        this.pids.set(newproc.pid, newproc);
        this.mailboxes.set(newproc.pid, newproc.mailbox);
        this.links.set(newproc.pid, new Set());
        if (linked) {
            this.link(newproc.pid);
        }
        if (monitored) {
            this.monitor(newproc.pid);
        }
        newproc.start();
        return newproc;
    };
    ProcessSystem.prototype.remove_proc = function (pid, exitreason) {
        var e_1, _a;
        this.pids.delete(pid);
        this.unregister(pid);
        this.scheduler.removePid(pid);
        var linkedPids = this.links.get(pid);
        if (linkedPids) {
            try {
                for (var linkedPids_1 = __values(linkedPids), linkedPids_1_1 = linkedPids_1.next(); !linkedPids_1_1.done; linkedPids_1_1 = linkedPids_1.next()) {
                    var linkpid = linkedPids_1_1.value;
                    this.exit(linkpid, exitreason);
                    var linkedPid = this.links.get(linkpid);
                    if (linkedPid) {
                        linkedPid.delete(pid);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (linkedPids_1_1 && !linkedPids_1_1.done && (_a = linkedPids_1.return)) _a.call(linkedPids_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.links.delete(pid);
        }
    };
    /**
     * registers the given name to the pid
     * @param name The name to give the process
     * @param pid The pid of the process
     */
    ProcessSystem.prototype.register = function (name, pid) {
        if (!this.names.has(name)) {
            this.names.set(name, pid);
        }
        else {
            throw new Error('Name is already registered to another process');
        }
    };
    /**
     * Finds a process by the given name
     * @param name the name of the process
     */
    ProcessSystem.prototype.whereis = function (name) {
        return this.names.has(name) ? this.names.get(name) : null;
    };
    /**
     * returns the liast of names that are registered
     */
    ProcessSystem.prototype.registered = function () {
        return this.names.keys();
    };
    /**
     * unregisters the names associated with the pid
     * @param pid The pid of the process
     */
    ProcessSystem.prototype.unregister = function (pid) {
        var e_2, _a;
        try {
            for (var _b = __values(this.names.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var name_1 = _c.value;
                if (this.names.has(name_1) && this.names.get(name_1) === pid) {
                    this.names.delete(name_1);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /**
     * Returns the PID of the current process
     */
    ProcessSystem.prototype.pid = function () {
        if (this.currentProcess) {
            return this.currentProcess.pid;
        }
        return null;
    };
    /**
     * takes the input and tries to find the pid. Input can be a `pid`, `Process`, or name the pid is associated with
     * @param id The registered name or pid of the process
     */
    ProcessSystem.prototype.pidof = function (id) {
        if (id instanceof ErlangTypes.ErlangPID) {
            return this.pids.has(id) ? id : null;
        }
        else if (id instanceof Process) {
            return id.pid;
        }
        else {
            var pid = this.whereis(id);
            if (pid === null)
                throw 'Process name not registered: ' + id + ' (' + typeof id + ')';
            return pid;
        }
    };
    /**
     * sends a message the the process represented by the pid
     * @param id
     * @param msg
     */
    ProcessSystem.prototype.send = function (id, msg) {
        var pid = this.pidof(id);
        if (pid) {
            var mailbox = this.mailboxes.get(pid);
            if (mailbox) {
                mailbox.deliver(msg);
            }
            if (this.suspended.has(pid)) {
                var fun = this.suspended.get(pid);
                this.suspended.delete(pid);
                if (fun) {
                    this.schedule(fun);
                }
            }
        }
        return msg;
    };
    /**
     * Tells the current process to receive a message that the function can handle.
     * If no match then the process is put in the suspended state until a message arrives
     * or the timeout is reached.
     * If the timeout is reached and no msg matches, then the timeoutFn is called
     * @param fun
     * @param timeout
     * @param timeoutFn
     */
    ProcessSystem.prototype.receive = function (fun, timeout, timeoutFn) {
        if (timeout === void 0) { timeout = 0; }
        if (timeoutFn === void 0) { timeoutFn = function () { return true; }; }
        var DateTimeout = null;
        if (timeout === 0 || timeout === Infinity) {
            DateTimeout = null;
        }
        else {
            DateTimeout = Date.now() + timeout;
        }
        return [process_states.RECEIVE, fun, DateTimeout, timeoutFn];
    };
    /**
     * puts the current process to sleep
     * @param duration
     */
    ProcessSystem.prototype.sleep = function (duration) {
        return [process_states.SLEEP, duration];
    };
    /**
     * Suspends the current process
     * @param fun
     */
    ProcessSystem.prototype.suspend = function (fun) {
        if (this.currentProcess) {
            this.currentProcess.status = process_states.SUSPENDED;
            this.suspended.set(this.currentProcess.pid, fun);
        }
    };
    /**
     * Makes current process go to sleep
     * @param fun
     * @param time
     */
    ProcessSystem.prototype.delay = function (fun, time) {
        if (this.currentProcess) {
            this.currentProcess.status = process_states.SLEEPING;
            if (Number.isInteger(time)) {
                this.scheduler.scheduleFuture(this.currentProcess.pid, time, fun);
            }
        }
    };
    /**
     * Schedules execution of a process reduction
     * @param fun
     * @param pid
     */
    ProcessSystem.prototype.schedule = function (fun, pid) {
        if (this.currentProcess) {
            var the_pid = pid != null ? pid : this.currentProcess.pid;
            this.scheduler.schedule(the_pid, fun);
        }
    };
    /**
     * terminates the current process with the given reason.
     * @param one
     * @param two
     */
    ProcessSystem.prototype.exit = function (one, two) {
        var e_3, _a;
        var pid = null;
        var reason = null;
        var process = null;
        if (two) {
            pid = one;
            reason = two;
            var thePid = this.pidof(pid);
            if (thePid) {
                process = this.pids.get(thePid);
            }
            if (process) {
                if (process.is_trapping_exits() ||
                    reason === process_states.KILL ||
                    reason === process_states.NORMAL) {
                    var mailbox = this.mailboxes.get(process.pid);
                    if (mailbox) {
                        mailbox.deliver(
                            ErlangTypes.ErlangTuple.create(
                            [process_states.EXIT, this.pid(), reason]));
                    }
                }
                else {
                    process.signal(reason);
                }
            }
        }
        else {
            if (this.currentProcess) {
                pid = this.currentProcess.pid;
                reason = one;
                process = this.currentProcess;
                process.signal(reason);
            }
        }
        if (process) {
            try {
                for (var _b = __values(process.monitors), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var ref = _c.value;
                    var mons = this.monitors.get(ref);
                    if (mons) {
                        this.send(mons['monitor'],
                            ErlangTypes.ErlangTuple.create(
                                ['DOWN', ref, mons['monitee'], mons['monitee'], reason]
                                ));
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    };
    /**
     * terminates the current process with an error
     * @param reason
     */
    ProcessSystem.prototype.error = function (reason) {
        if (this.currentProcess) {
            this.currentProcess.signal(reason);
        }
    };
    /**
     * Sets flags on the current process.
      - Note: the only flag respected is the `Symbol.for("trap_exit")` flag.
      If value is `true`, then exit signals from linked processes are turned into
      messages and sent to the current processes mailbox.
      If value is `false`, the exit is treated as normal and terminates the process.
      Setting it to `true` is useful for supervising processes.
     * @param args
     */
    ProcessSystem.prototype.process_flag = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length == 2) {
            var flag = args[0];
            var value = args[1];
            if (this.currentProcess) {
                return this.currentProcess.process_flag(flag, value);
            }
        }
        else {
            var pid = this.pidof(args[0]);
            if (pid) {
                var flag = args[1];
                var value = args[2];
                var process_5 = this.pids.get(pid);
                if (process_5) {
                    return process_5.process_flag(flag, value);
                }
            }
        }
    };
    /**
     * Adds a value to the current process's dictionary
     * @param key
     * @param value
     */
    ProcessSystem.prototype.put = function (key, value) {
        if (this.currentProcess) {
            this.currentProcess.dict.set(key, value);
        }
    };
    /**
     * Gets the current process's dictionary
     */
    ProcessSystem.prototype.get_process_dict = function () {
        if (this.currentProcess) {
            return this.currentProcess.dict;
        }
        throw new Error('No Current Process');
    };
    /**
     * Gets a value from the current process's dictionary or the default if key not in dictionary
     * @param key
     * @param default_value
     */
    ProcessSystem.prototype.get = function (key, default_value) {
        if (default_value === void 0) { default_value = null; }
        if (this.currentProcess && key in this.currentProcess.dict) {
            return this.currentProcess.dict.get(key);
        }
        else {
            return default_value;
        }
    };
    /**
     * Gets all the keys from the current process's dictionary
     * @param value
     */
    ProcessSystem.prototype.get_keys = function (value) {
        var e_4, _a;
        if (value) {
            var keys = [];
            if (this.currentProcess) {
                try {
                    for (var _b = __values(Object.keys(this.currentProcess.dict)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var key = _c.value;
                        if (this.currentProcess.dict.get(key) === value) {
                            keys.push(key);
                        }
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
            return keys;
        }
        if (this.currentProcess) {
            return Object.keys(this.currentProcess.dict);
        }
        throw new Error('No Current Process');
    };
    /**
     * Removes the key and the associated value from the current process's dictionary
     *
     * If no key is given, removes all entries from the current process's dictionary
     * @param key the key to remove
     */
    ProcessSystem.prototype.erase = function (key) {
        if (this.currentProcess) {
            if (key != null && this.currentProcess.dict.has(key)) {
                this.currentProcess.dict.delete(key);
            }
            else {
                this.currentProcess.dict = new Map();
            }
        }
    };
    /**
     * Returns if the given pid is alive
     * @param pid
     */
    ProcessSystem.prototype.is_alive = function (pid) {
        var real_pid = this.pidof(pid);
        return real_pid != null;
    };
    /**
     * Returns a list of all the pids
     */
    ProcessSystem.prototype.list = function () {
        return Array.from(this.pids.keys());
    };
    /**
     * Returns a unique reference
     */
    ProcessSystem.prototype.make_ref = function () {
        return ErlangTypes.ErlangReference.create(1);
    };
    Object.defineProperty(ProcessSystem.prototype, "currentProcess", {
        get: function () {
            if (this.current_process) {
                return this.current_process;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    return ProcessSystem;
}());

console.log(new ProcessSystem());

/* FFI CODE */
exports.do_apply_4 =
    function(moduleName) {
        return function(functionName) {
            return function(argumentArray) {
                return function(failCallback) {
                    var module = undefined;
                    var f = undefined;
                    try {
                        let name = moduleName.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
                        try {
                            module = PS[name];
                        } catch(e) {
                            module = require("../"+name+"/index.js");
                        }
                        f = module["erlps__" + functionName + "__" + argumentArray.length]
                    } catch(e) {
                        module = undefined;
                        f = undefined;
                    }
                    if (module !== undefined && f !== undefined) {
                        return f()(argumentArray);
                    } else {
                        failCallback()
                    }
                }
            }
        }
    };
